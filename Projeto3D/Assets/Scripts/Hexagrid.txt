using System;
using System.Collections.Generic;
using UnityEngine;

using Random = System.Random;
using Vector2 = UnityEngine.Vector2;

namespace Hexagrid
{
    public class Grid
    {
        int sideSize = 0;
        public int baseQuadCount = 0;
        int searchIterationCount = 0;

        const float angle = 60;
        const float angleRad = angle * Mathf.Deg2Rad;
        static float sideLength = Mathf.Tan(angleRad) / 2; 
            
        public List<Point> points;
        public List<Triangle> triangles;
        public List<Quad> quads;
        public List<Neighbours> neighbours;


        public Grid(int sideSize, int seed, int searchIterationCount)
        {
            this.searchIterationCount = searchIterationCount;
            
            points = new List<Point>();
            triangles = new List<Triangle>();
            quads = new List<Quad>();

            this.sideSize = (sideSize < 2) ? 2 : sideSize;

            for (int x = 0; x < (sideSize * 2 - 1) ; x++)
            {
                int height = (x < sideSize) ? (sideSize + x) : (sideSize * 3 - 2 - x);
                float deltaHeight = sideSize - height * 0.5f;

                for (int y = 0; y < height; y++)
                {
                    bool isSide = 
                        (x == 0) || 
                        (x == (sideSize * 2 - 2)) || 
                        (y == 0) || 
                        (y == height-1);

                    points.Add(
                        new Point(
                            (x - sideSize + 1) * sideLength, 
                            y + deltaHeight, 
                            isSide));
                }
            }

            int offset = 0;
            
            for (int x = 0; x < (sideSize * 2 - 2); x++)
            {
                int height = (x < sideSize) ? (sideSize + x) : (sideSize * 3 - 2 - x);
                if (x < sideSize - 1)
                {
                    // left side
                    for (int y = 0; y < height; y++)
                    {
                        triangles.Add(
                            new Triangle(
                                offset + y, 
                                offset + y + height, 
                                offset + y + height + 1 ));

                        if (y >= height - 1)
                        {
                            break;
                        }

                        triangles.Add(
                            new Triangle( 
                                offset + y + height + 1, 
                                offset + y + 1, 
                                offset + y ));
                    }
                }

                else
                {
                    // right side
                    for (int y = 0; y < height - 1; y++)
                    {
                        triangles.Add(
                            new Triangle(
                                offset + y, 
                                offset + y + height, 
                                offset + y + 1 ));

                        if (y >= height - 2)
                        {
                            break;
                        }

                        triangles.Add(
                            new Triangle(
                                offset + y + 1, 
                                offset + y + height, 
                                offset + y + height + 1 ));
                    }
                }

                offset += height;
            }

            // triangles to quads

            int triIndex;
            int[] adjacents = new int[3];
        
            Random rand = new Random(seed);

            while(true)
            {
                int searchCount = 0;
                do
                {
                    triIndex = rand.Next() % triangles.Count;
                    searchCount++;
                }
                while(searchCount < searchIterationCount && !triangles[triIndex].isValid);

                if (searchCount == searchIterationCount)
                {
                    break;
                }

                int adjacentCount = GetAdjacentTriangles(triIndex, ref adjacents);

                if (adjacentCount > 0)
                {
                    int i1 = triIndex;
                    int i2 = adjacents[0];

                    int[] indices = 
                    { 
                        triangles[i1].a, triangles[i1].b, triangles[i1].c,
                        triangles[i2].a, triangles[i2].b, triangles[i2].c 
                    };

                    Array.Sort(indices);


                    int[] quadIndices = new int[4];
                    int quadIndexCount = 1;
                    
                    quadIndices[0] = indices[0];


                    for (int i = 1; i < 6; i++)
                    {
                        if (indices[i] != indices[i-1])
                        {
                            quadIndices[quadIndexCount++] = indices[i];
                        }
                    }

                    Debug.Assert(quadIndexCount == 4);

                    quads.Add(
                        new Quad(
                            quadIndices[0], 
                            quadIndices[2], 
                            quadIndices[3], 
                            quadIndices[1]));

                    triangles[triIndex].isValid = false;
                    triangles[adjacents[0]].isValid = false;
                }
            }

            Dictionary<int, int> middles = new Dictionary<int, int>();

            // quads to 4 quads
            baseQuadCount = quads.Count;

            for (int i = 0; i < baseQuadCount; i++)
            {
                Quad quad = quads[i];

                int indexCenter = points.Count;
                
                points.Add(
                    new Point(
                        (points[quad.a].position + points[quad.b].position + points[quad.c].position + points[quad.d].position) * 0.25f));  

                Subdivide(4, quad.indexes, in middles, indexCenter);
            }

            // triangles to quads
            foreach(Triangle triangle in triangles)
            {
                if (triangle.isValid)
                {   
                    int indexCenter = points.Count;
                    
                    points.Add(
                        new Point((points[triangle.a].position + points[triangle.b].position + points[triangle.c].position) * 0.3333f));
                    
                    Subdivide(3, triangle.indexes, middles, indexCenter);
                }
            }
            
            // neighbours
            neighbours = new List<Neighbours>(points.Count);

            for (int i = baseQuadCount; i < quads.Count; i++)
            {
                Quad quad = quads[i];

                for (int j = 0; j < 4; j++)
                {
                    int index1 = quad.indexes[j];
                    int index2 = quad.indexes[ (j + 1) & 3];
                    {
                        Neighbours neighbour = neighbours[index1];
                        // check
                        bool good = true;
                        for (int k = 0; k < neighbour.neighbourCount; k++)
                        {
                            if(neighbour.neighbour[k] == index2)
                            {
                                good=false;
                                break;
                            }
                        }
                        if (good)
                        {
                            Debug.Assert(
                                neighbour.neighbourCount < Neighbours.MAX_NEIGHBOURS);
                            
                            neighbour.neighbour[neighbour.neighbourCount++] = index2;
                        }
                    }
                    {
                        Neighbours neighbour = neighbours[index2];
                        // check
                        bool good = true;
                        for (int k = 0; k < neighbour.neighbourCount; k++)
                        {
                            if(neighbour.neighbour[k] == index1)
                            {
                                good=false;
                                break;
                            }
                        }
                        if (good)
                        {
                            Debug.Assert(neighbour.neighbourCount < Neighbours.MAX_NEIGHBOURS);
                            neighbour.neighbour[neighbour.neighbourCount++] = index1;
                        }
                    }
                }
            }
        }

        public int GetAdjacentTriangles(int triIndex, ref int[] adjacents)
        {
            int[] referenceTriangle =
            {
                triangles[triIndex].a, 
                triangles[triIndex].b,
                triangles[triIndex].c
            };

            int index = 0;
            for (int i = 0; i< triangles.Count; i++)
            {
                if (i == triIndex || !triangles[i].isValid)
                {
                    continue;
                }

                int[] localTriangles = 
                {   
                    triangles[i].a,
                    triangles[i].b,
                    triangles[i].c 
                };

                int shareCount = 0;
                for(int j = 0; j < 3; j++)
                {
                    for (int k = 0; k < 3; k++)
                    {
                        if (referenceTriangle[j] == localTriangles[k])
                        {
                            shareCount ++;
                            break;
                        }
                    }
                }

                Debug.Assert(shareCount < 3);

                if (shareCount == 2)
                {
                    Debug.Assert(index < 3);
                    adjacents[index++] = i;
                }
            }

            return index;
        }

        public void Subdivide(int count, in int[] index, in Dictionary<int, int> middles, int indexCenter) 
        {
            int[] halfSegmentIndex = new int[count];

            for (int j = 0; j < count; j++)
            {
                int indexA = index[j];
                int indexB = index[(j + 1) % count];

                int key = (Math.Min(indexA, indexB) << 16) + Math.Max(indexA, indexB);

                if (!middles.ContainsKey(key))
                {
                    halfSegmentIndex[j] = points.Count;
                    
                    bool isSide = points[indexA].isSide && points[indexB].isSide;
                    
                    points.Add(
                        new Point((points[indexA].position + points[indexB].position) * 0.5f, isSide ));

                    middles.Add(key, halfSegmentIndex[j]);
                }
                else
                {
                    halfSegmentIndex[j] = middles[key];
                }
            }

            for (int j = 0; j < count; j++)
            {
                int nextIndex = (j + 1) % count;
                quads.Add(
                    new Quad(
                        indexCenter, 
                        halfSegmentIndex[j], 
                        index[nextIndex], 
                        halfSegmentIndex[nextIndex]));
            }
        }
        
        public void Relax()
        {
            for (int i = 0; i < points.Count; i++)
            {
                if (points[i].isSide)
                {
                    continue;
                }

                Vector2 sum = new Vector2(0, 0);
                
                for (int j = 0; j < neighbours[i].neighbourCount; j++)
                {
                    sum += points[neighbours[i].neighbour[j]].position;
                }
                
                sum /= neighbours[i].neighbourCount;
                points[i].position = sum;
            }
        }

        public void RelaxSide()
        {
            float radius = sideSize - 1f;
            Vector2 center = new Vector2(0f, (sideSize * 2 - 1) * 0.5f);

            for (int i = 0; i < points.Count; i++)
            {
                if (!points[i].isSide)
                {
                    continue;
                }

                Vector2 D = points[i].position - center;
                float distance = radius - Mathf.Sqrt(D.x * D.x + D.y * D.y);

                points[i].position += 0.1f * distance * D;
            }
        }

        // Vector2 worldToScreen(Vector2 point)
        // {
        //     ImGuiIO& io = ImGui::GetIO();
        //     float ratio = io.DisplaySize.x / io.DisplaySize.y;
        //     ImVec2 res = (point / (sideSize * 3.5f));
        //     res.y *= ratio;
        //     res = res * io.DisplaySize;
        //     res += ImVec2(io.DisplaySize.x / 2.f, 0.f);
        //     return res;
        // }
    };

    public class Point
    {
        public Vector2 position;
        public bool isSide = false;

        public Point(Vector2 position, bool isSide = true)
        {
            this.position = position;
            this.isSide = isSide;
        }

        public Point(float x, float y, bool isSide = true)
        {   
            this.position = new Vector2(x, y);
            this.isSide = isSide;
        }
    };

    public class Triangle
    {
        public int[] indexes = new int[3];
        public int a 
        {
            get { return indexes[0]; }
            set { indexes[0] = value; }
        }
        public int b 
        {
            get { return indexes[1]; }
            set { indexes[1] = value; }
        }
        public int c
        {
            get { return indexes[2]; }
            set { indexes[2] = value; }
        }

        public bool isValid = true;

        public Triangle(int a, int b, int c, bool isValid = true)
        {
            this.a = a;
            this.b = b;
            this.c = c;
            this.isValid = isValid;
        }
    };

    public class Quad
    {
        public int[] indexes = new int[4];
        public int a 
        {
            get { return indexes[0]; }
            set { indexes[0] = value; }
        }
        public int b 
        {
            get { return indexes[1]; }
            set { indexes[1] = value; }
        }
        public int c
        {
            get { return indexes[2]; }
            set { indexes[2] = value; }
        }
        public int d
        {
            get { return indexes[3]; }
            set { indexes[2] = value; }
        }

        public Quad(int a, int b, int c, int d)
        {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        }
    };

    public class Neighbours
    {
        public const int MAX_NEIGHBOURS = 6;

        public int neighbourCount = 0;
        public int[] neighbour = new int[MAX_NEIGHBOURS];
    };
}