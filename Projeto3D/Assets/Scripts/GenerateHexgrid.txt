

using System.Collections.Generic;
using Hexagrid;
using UnityEngine;
using Grid = Hexagrid.Grid;

class GenerateHexgrid : MonoBehaviour
{
    Grid grid;

    void DrawGrid(bool drawPositions, bool drawSector)
    {
        ImDrawList* mDrawList;
        ImGuiIO& io = ImGui::GetIO();

        const ImU32 flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoBringToFrontOnFocus;

    #ifdef IMGUI_HAS_VIEWPORT
        ImGui::SetNextWindowSize(ImGui::GetMainViewport()->Size);
        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->Pos);
    #else
        ImGui::SetNextWindowSize(io.DisplaySize);
        ImGui::SetNextWindowPos(ImVec2(0, 0));
    #endif

        ImGui::PushStyleColor(ImGuiCol_WindowBg, 0);
        ImGui::PushStyleColor(ImGuiCol_Border, 0);
        ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

        ImGui::Begin("debugDraw", NULL, flags);
        mDrawList = ImGui::GetWindowDrawList();
        ImGui::End();
        ImGui::PopStyleVar();
        ImGui::PopStyleColor(2);


        if (drawPositions)
        {
            foreach (Point point in grid.points)
            {
                mDrawList->AddCircleFilled(grid.worldToScreen(point.position), 5, point.isSide?0xFF303030:0xFF404040);
            }
        }
        if (drawSector)
        {
            foreach (Triangle triangle in grid.triangles)
            {
                if (!triangle.isValid)
                {
                    continue;
                }
                
                Vector2[] screenPoint = new Vector2[] {
                    grid.worldToScreen(grid.points[triangle.a].position),
                    grid.worldToScreen(grid.points[triangle.b].position),
                    grid.worldToScreen(grid.points[triangle.c].position),
                };

                mDrawList->AddPolyline(screenPoint, 3, 0xFFA0A0A0, true, 2.f);
            }
        
            for (int i = 0; i < grid.baseQuadCount; i++)
            {
                Quad quad = grid.quads[i];

                Vector2[] screenPoint = new Vector2[] {
                    grid.worldToScreen(grid.points[quad.a].position),
                    grid.worldToScreen(grid.points[quad.b].position),
                    grid.worldToScreen(grid.points[quad.c].position),
                    grid.worldToScreen(grid.points[quad.d].position),
                };

                mDrawList->AddPolyline(screenPoint, 4, 0xFFFFFFFF, true, 2.f);
            }
        }
        else
        {
            for (int i = 0; i < grid.points.size(); i++)
            {
                Neighbours neighbour = grid.neighbours[i];
                Vector2 ptA = grid.worldToScreen(grid.points[i].position);
                for (int j = 0; j < neighbour.neighbourCount; j++)
                {
                    Vector2 ptB = grid.worldToScreen(grid.points[neighbour.neighbour[j]].position);
                    mDrawList->AddLine(ptA, ptB, 0xFFB0B0B0, 2.f);
                }
            }
        }
    }

    void Start()
    {
        ImApp::ImApp imApp;

        ImApp::Config config;
        config.mWidth = 1280;
        config.mHeight = 720;
        //config.mFullscreen = true;
        imApp.Init(config);

        // Main loop
        while (!imApp.Done())
        {
            imApp.NewFrame();

            ImGuiIO& io = ImGui::GetIO();
            static bool firstFrame = true;
            static bool relaxIt = true;
            static bool relaxSide = false;
            static bool drawPositions = false;
            static bool drawSector = false;
            bool dirty = firstFrame;
            ImGui::Begin("Parameters");
            static int sideCount = 6;
            static int searchIterationCount = 6;
            static int seed = 1337;
            dirty |= ImGui::SliderInt("Sides", &sideCount, 2, 12);
            dirty |= ImGui::SliderInt("Seed", &seed, 1, 65535);
            dirty |= ImGui::SliderInt("Grouping", &searchIterationCount, 1, 20);
            dirty |= ImGui::Checkbox("Relax", &relaxIt);
            if (relaxIt)
            {
                dirty |= ImGui::Checkbox("Relax Side", &relaxSide);
            }

            ImGui::Checkbox("Draw Positions", &drawPositions);
            ImGui::Checkbox("Draw Sectors", &drawSector);

            ImGui::End();
            if (dirty)
            {
                grid = new Grid(sideCount, seed, searchIterationCount);
                firstFrame = false;
            }
            if (relaxIt)
            {
                grid.Relax();
            }
            if (relaxIt&&relaxSide)
            {
                grid.RelaxSide();
            }
            DrawGrid(drawPositions, drawSector);

            // render everything
            glClearColor(0.48f, 0.38f, 0.4f, 1.f);
            glClear(GL_COLOR_BUFFER_BIT);
            ImGui::Render();

            imApp.EndFrame();
        }

        imApp.Finish();
    }
}